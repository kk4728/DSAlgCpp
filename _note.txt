







Ch02 程序性能分析

	2.3.4 步数
		程序步：一个语法或语义上的程序段，该片段的执行时间独立于实例特征。 在不同的程序中，程序步所定义的意义可能不同
		可以通过定义一个初始值为0的全局变量，把这个变量嵌入到程序中去。

		如果不想嵌入stepCount增值语句，可以建立一张表，列出每条语句的总步数。所以，首先要确定每条语句每次执行所需要的步数(s/e,steps per execution),
		以及该语句总的执行次数(频率)，然后两者相乘即是该条语句的总步数，最后把所有总步数加起来就是整个程序的步数，该方法称为剖析法。

		最好、最坏、平均操作计数

Ch03 渐进记法
	
	3.2渐近记法
		3.2.1 大O
		
	3.5 实际复杂度
		程序性能判断，一般采用足够大的实例特征来判断(极限)->∞，但对于足够大，我们始终需要关注它的意义。在对两个程序进行取舍时，必须清楚实例特征n是否真的足够大。
		即，指数复杂度不一定就比平方数运行的慢，取决于n的取值范围。
		一个函数的复杂度如果是高次多项式，必须限制使用。否则当n足够大时，程序运行时间过长，该函数就没有了意义。

Ch04 性能测试
	程序性能不仅依赖于操作类型和数量，也依赖数据和指令的内存模式。计算机内存是有等级之分的，例如寄存器 > L1高速缓存 > L2高速缓存 > 主存
	
	4.1 引言
		在windows中，时间优化可使用 #progma optimize("t", on)
	4.4 实验设计
		C++中并没有计算函数时间精度的函数，clock()获取函数运行时系统滴答数，如果精度不够，可以通过多次运行同样次数的实例特征，积累一定的可测量的时间。然后去掉包含实例特征函数
		再次测试时间，两者相减即得到包含实例特征函数的时间复杂度度量值。当然，也可采用高精度的计时器，但如果函数运行实在太快，还是会遇到这个问题。
		最好不要采用以下方法来测试时间；
		elapseTime = 0;
		n=0;
		do 
		{
			n++;
			startTime = clock();
			dosomething();
			elapseTime += clock() - startTime;
		}while(elapseTime < 1000);
		因为如果dosomething()运行较快，两次clock()函数得到的是同一个时钟滴答数，导致本累加差值为0，计算不准确。(系统时钟滴答精度不高造成的)

		而要采用以下方式:
		n=0;
		startTime=clock();
		do
		{
			n++;
			dosomething();
			
		}while(clock() - startTime < 1000);

